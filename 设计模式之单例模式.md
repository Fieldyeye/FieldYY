### 单例模式简介
Singleton模式一般的实现只需要一个类就能完成，在这唯一类中，单例模式确保此类只有一个实例，自行实例化并提供一个访问它的全局公有静态方法。

- 两种适用场景：

  1. 产生某对象会消耗过多的资源，为避免频繁创建与销毁对象对资源的浪费。如：
  
      >对数据库的操作、访问IO、线程池（threadpool）、网络请求等。
    
  2. 某种类型的对象有且只有一个。如果制造出多个这样的实例。可能导致：程序行为异常、资源使用过量、结果不一致等问题。如果多人能同时操作一个文件，又不进行版本管理，必然会有的修改被覆盖。所以：
  
      >一个系统只能有：一个窗口管理器或文件系统，计时工具或ID（序号）生成器，缓存（cache），处理偏好设置和注册表（registry）的对象，日志对象。
      
      
- 优点：减少系统内存开支，减少系统性能开销，避免对资源的多重占用、同时操作。
- 缺点：扩展困难，容易引发内存泄漏，测试困难，一定程度违背了单一职责原则，进程被杀时可能有状态不一致问题。


### 单例的各种实现

  按加载时机可分为：饿汉方式和懒汉方式；按实现的方式：双重检查加锁，内部类方式和枚举方式等等，另还有一种通过Map容器管理方式
  
  
  无论哪一种形式实现单例模式，本质都是使单例类的构造函数对其他类不可见，仅提供获取唯一一个实例的静态方法，必须保证这个实例的方法是线程安全的，并防止反序列化、反射、克隆、多个类加载器、分布式系统等多种情况下重新升成新的实例对象。
  
  ![](https://pic4.zhimg.com/v2-b04c81ebff931b81ec80d1894a2856b3_b.png)
  
  下面四种单例实现方式都是线程安全的，是实现单例时不错的选择：
  
  ![](https://pic1.zhimg.com/v2-92a90c4a221eea15469a9d02297ad544_b.jpg)
  
  
  ### 线程安全

   最简单的懒汉方式：
    
  ![](https://pic3.zhimg.com/v2-0adb474e4485a07da134b154dae5814a_b.png)
  
   此写法只能在单线程下使用。如果是多线程，可能发生一个线程通过并进入了 if (singleton == null) 判断语句块，但还未来得及创建新的实例时，另一个线程也通过了这个判断语句，两个线程最终都进行了创建，导致多个实例的产生。所以在多线程环境下必须摒弃此方式。
   
   双重检查锁定”（Double Check Lock（DCL））方式：
   
  ![](https://pic4.zhimg.com/v2-b32de456954f1b96ce7efe91a19b947f_b.png)
  
  双重检查锁定（DCL）方式也是延迟加载的。此方法的“Double-Check”体现在进行了两次 if (singleton == null) 的检查，这样既同步代码块保证了线程安全，同时实例化的代码也只会执行一次，实例化后同步操作不会再被执行，从而效率提升很多。
  
  
  
  “静态内部类”方式：
  
  ![](https://pic3.zhimg.com/v2-405dd38000c4fa31d46ebfbed6fc5672_b.png)
  
  这种方式利用了 classloder 的机制来保证初始化 instance 时只会有一个。需要注意的是：虽然它的名字中有“静态”两字，但它是属于“懒汉模式”的！！这种方式的 Singleton 类被装载时，只要 SingletonHolder 类还没有被主动使用，instance 就不会被初始化。只有在显式调用 getInstance() 方法时，才会装载 SingletonHolder 类，从而实例化对象。
  
  
  “静态内部类”方式基本上弥补了 DCL 方式在 JDK 版本低于 1.5 时高并发环境失效的缺陷。此方式并不特别常见，然而它是所有懒加载的单例实现中适用范围最广、限制最小、最为推荐的一种。
  
  
  
### 加载时机  
